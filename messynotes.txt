MEMORY MAP

00980000-00A7FFFF: 1mb RAM
00600000-0061FFFF: video RAM, multiplexed between two planes, each with 64kb x 4bits of data
00000000-0000FFFF: 64kb ROM
		 
Stuff happens in ROM regarding data in a60000-a6ffff, so it's probably safest to 
end program storage at a5ffff.
		 

EXECUTABLE FILE FORMAT

LIF file type 0xC001

0x0000: dword:    length
0x0004: char[20]: comment (space filled)
0x0024: dword:	  code length
0x0028: dword:    code loading location, normally 0x00984500
0x002C: char[code length]:  code
0x002c + code length: dword:   data(?) loading location, 0x00A20000 in PVTEST_ and SYSTEM_
0x002c + code length + 4: data to end of file

Observed initial stack pointer : 00A7FFDE 

Strings are null terminated.


VIDEO

Screen size: 592x384
Some of the ROM routines (e.g., DrawText) enforce an 8-pixel margin.

The video memory consists of two bit-planes, a data plane and an attribute plane.
The CRT shows the xor of the values in the two planes, with 1=white and 0=black. 

This allows one to have cursors and selection boxes without rewriting screen data, 
by putting the cursor images and boxes in the attribute plane and thereby inverting 
what's in the data plane.

The two planes are multiplexed for access at 0x600000. The data is stored row by
row, with four bits per machine word. Only the lowest four bits of each machine
word are valid, and they are displayed left-to-right from lowest to highest bit
(not quite what you would expect on a big-endian system).

Screen address (x,y) corresponds to the word at address: 0x600000 + y*0x0128 + x/4*2,
with the relevant bit being 3-(x&0x3). 

Only 1 bits affect anything as they are written to screen memory: 0 bits are
completely ignored. To write a bit 1 to (x,y), you write a word to 
0x600000 + y*0x0128 + x/4*2 with the lowest byte 8>>(x&0x3).

Both planes share the same addresses. At 0x00201000 there is a one-word screen memory 
control register that controls the multiplexing mode for the memory. This allows you
to control both which plane(s) you are writing to as well as whether writing a 1 bit
sets a bit or clears a bit in the plane(s).

Only the lowest 4 bits of each byte of the mode register matter. Here are expecially  
useful modes:
 f0a  = write black pixels (clear to 0) to data, leave attribute alone, read data
 e0a  = write white pixels (set to 1) to data, leave attribute alone, read data
 007  = set attribute bits, leave data alone, read attribute
 f07  = clear attribute bits, leave data alone, read attribute
 906  = write black pixels (clear bits) to data, clearing attribute pixels, read data|attr
 a06  = write white pixels (set bits) to data, clearing attribute pixels, read data|attr
 009  = NOP: no writing (or reading)

If you don't want to use the attribute plane, you can just alternate between modes a06 (white)
and 906 (black), and if you used one of these modes to set or clear or all pixels, then reading
gives you the pixel data, as it will be an OR between data and attribute, but the attribute
will always be one.

A full list of the modes is in screenmodes.txt. It was based on automated data gathering via
the c/idscreenmode program.

Font bitmap locations: a674 (bold), 9e74; 16 bytes per char 


INTERRUPTS

The Level 1 interrupt autovector is at 60Hz, so it's surely the vertical blanking interrupt.
It can be used for a timer. 


SPECIAL HARDWARE ADDRESSES

0x201000.w: screen memory control (see above)  
0x203000.b: BEEP: 0xFF on, $FE off
0x206000.b: spinner speed
0x207000.l (write): -1 does something spinnery
0x20d003.l: read/write. unknown. Serial port??
0x20F000.w:
	bit 0: unknown, checked in a disc related context
	bit 1: last spinner turn was to the right
	bit 3: no disc in drive


ROM ROUTINES

ead8: rectangle: 7,h,w,y,x ???? not quite
eac6: 8,8,170,240 (after 0000eaae : fe) : clears rectangle on screen
eaba: set high byte of 0x201000 mode register to the logical not of the uint16_t argument
eade: bold : set bold if 1, set normal if 0
eb08: text mode?? : 0 = black on white (9800b2 set to 4) ; else: white background, no text (9800b2 set to 7)
eae4: y,x : set coordinates
eaf6: DrawText: print 0-terminated string
eacc: 2,coordinates,coordinates :  
ecd0: beep --> 0F70
ece2: reload system!
eb38: get key --> D0w  [ actual code at 12F4 ] ; sometimes waits, sometimes doesn't ??!
ec58 ?? write text at coordinates: 0.w, y.w, x.w, message.l, implemented at b164
calls 0F8E(1.l,1.l)
ec76: strcpy(dest,src)
ec94: strcat(dest,src)

trap #0 with D7=1C and D0=argument: pause for 16.9ms times argument (number of display frames, presumably)
D7=1D has similar arguments, but functionality is unknown; the 1C handler is apparently at 60000D70
trap handler starts at #6B52


KEYBOARD

ROM keyboard handler maintains this data:
at 0x980700.w:  the current key
at 0x980702.b: 03 if a key is pressed and 00 otherwise
at 0x980704.w: the last key pressed (FFFF if spinner)
at 0x980706.b: 01 if last event was spinner and 00 if it was a key
at 0x98070A.w: the duration of last key down event (including spinner in any direction)
at 0x9a070C.b: 01 if last spinner movement was right and FF if it was left
at 0x9a070D.b: some sort of spinner speed value
at 0x9a070E.w: some kind of current spinner position, not corresponding to angle : a full rotation is about 115-122

  none = 0000 
  0 = 0240
  . = 0440
  chs = 0840
  1 = 0220
  2 = 0420
  3 = 0820
  4 = 0210
  5 = 0410
  6 = 0810
  clr = 0120
  stop = 0104
  7 = 0208
  8 = 0408
  9 = 0808
  don't care = 0110
  run = 0102
  A = 0204
  B = 0404
  C = 0804
  D = 0202
  E = 0402
  F = 0802
  format = 0101
  trace = 0201
  display = 0401
  io = 0801
  updown = 1040
  leftright = 2040
  select = 2001
  counterclockwise = 0082
  clockwise = 0081


DISK I/O

eb74 int OpenFile(char *filename,int filetype,int mode)
 Modes are either 1 (read) or 2 (write)
 E.g.: OpenFile(s_AUTOLOAD_000064da,0xc301,2);
       OpenFile("SYSTEM_",0xc001,1);
       OpenFile("PVTEST_",0xc001,1);	   
implemented at 390C	   
	
eb86 int ReadFile(int fd, void* out, int size) 
	if size is -1, reads to end (dangerous if you don't know the size)
	if out is NULL and size <= 64K, it presumably writes to ROM (I've seen this in ROM code to skip stuff in the file)
implemented at 3c98

eb80 int WriteFile(int fd,void* in,int size)
implemented at 3f96

eb7a CloseFile(int fparam)
implemented at 3a5c

eb98 FindDirEntry(char* filename,int16 type,char* direntry32bytes,uint32 searchStartIndex,uint32 filename_length)
	return -5 if filename doesn't exist; returns index in directory otherwise.
	These are standard LIF directory entries.

ebce int GetDirEntry(int32 index,char* direntry32bytes);  returns -1 when done

0x984166: some kind of open file info area, with entries of length 0x138?	   

eb92: check if packing is needed??

eb9e: pack??

eb62: some kind of directory refresh
ebb0: some sort of status check; 0=ok  

ROM code suggests that only one file can be open at once, as some routines check to see if fparam is <= 0
and exit if not.


Some PVTEST_ functions:
FUN_00993044: args: push string, push length 
FUN_00992ff6: DrawText: push string, zero terminated
FUN_00992fc0: DrawRect:
 push thickness, height, width, y, x
LAB_00992fe6+4: DrawChar: push char (.w) to draw
FUN_00992fde.l: SetBold: push word: 1 bold, 0 normal
FUN_00993014: takes two coordinate pairs; line?
0098a078: DrawKeyboard
0098a934: TestKeys
FUN_00993038: get key --> D0 ; probably -1 is none


NOTES ON SYSTEM_

009c2482: SystemOpenFile (calls ROM's OpenFile)

Serial programming token/command table starts:
 00a023b8: string: COM^MAND [null terminated, 0x20 padded after null] : 0x0E bytes
           word: some sort of index that is non-increasing from entry to entry, sometimes staying the same
Address of token table stored in 00a23b8a		   

