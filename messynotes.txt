MEMORY MAP
00980000-00A7FFFF: 1mb RAM
00000000-0000FFFF: 64kb ROM
		 
Stuff happens in ROM regarding data in a60000-a6ffff, so it's probably safe to 
end program storage at a5ffff.		 
		 
EXECUTABLE FILE FORMAT
LIF file type 0xC001

0x0000: dword:    length
0x0004: char[20]: comment (space filled)
0x0024: dword:	  code length
0x0028: dword:    code loading location, normally 0x00984500
0x002C: char[code length]:  code
0x002c + code length: dword:   data(?) loading location, 0x00A20000 in PVTEST_ and SYSTEM_
0x002c + code length + 4: data to end of file

Observed initial stack pointer : 00A7FFDE 

Strings are null terminated.

Screen size: 592x384
Some of the ROM routines (e.g., DrawText) enforce an 8-pixel margin.

From PVTEST_

992fe2+2: SetCoordinates:  push y, x
        0098a500 48  78  00       pea        (0xb4 ).w
                 b4
        0098a504 48  78  01       pea        (0x15c ).w
                 5c
        0098a508 4e  93           jsr        (A3 => LAB_00992fe2+2 )
        0098a50a 50  8f           addq.l     #0x8 ,SP

FUN_00993044: args: push string, push length 
FUN_00992ff6: DrawText: push string, zero terminated
FUN_00992fc0: DrawRect:
 push thickness, height, width, y, x
LAB_00992fe6+4: DrawChar: push char (.w) to draw
FUN_00992fde.l: SetBold: push word: 1 bold, 0 normal
FUN_00993014: takes two coordinate pairs; line?
0098a078: DrawKeyboard
0098a934: TestKeys
FUN_00993038: get key --> D0 ; probably -1 is none

at 600000: graphics memory, draw in white by default.

screen: write word at a time to even addresses ; only lowest 4 bits matter

To switch to black:
    move.w     #4 ,-(SP ) ; other values 0,1,FF ;
    jsr        $0000eaba
    addq.l     #2 ,SP
 FF does nothing?!  00 draws black, 04 draws black, 

05 : unknown! ---> ~05 becomes the high byte at 0x201000; low byte comes from 98077c.

low byte values: f0,f8,

font locations: a674 (bold), 9e74; 16 bytes per char 

To turn off writing:
    move.w     #$fe ,-(SP )
    jsr        $0000eaae
    addq.l     #2 ,SP
# f1, f9, -9, fd, fb have been sighted

The Level 1 interrupt autovector is at 60Hz, so it's probably the vertical blanking interrupt.
It can be used for a timer. 
 
$980716 is copied to $202000
 
Draw pixel in SYSTEM_:

void FUN_00a04b12(ushort param_1,ushort param_2)
{
  ushort uVar1;
  
  uVar1 = 8;
  if ((param_1 & 3) != 0) {
    uVar1 = 8 >> (param_1 & 3);
  }
  (x/4)*2 + y*(592/2) = 8 >> (x % 8)
  *(ushort *)((uint)((param_1 & 0xfffc) >> 1) + (uint)param_2 * 0x128 + 0x600000) = uVar1;
  return;
}

// only the last 4 bits of each display byte are used

From SYSTEM_:
	009c2482: SystemOpenFile (calls ROM's OpenFile)
	

ROM routines:

ead8: rectangle: 7,h,w,y,x ???? not quite

ea06: one arg 1e

eac6: 8,8,170,240 (after 0000eaae : fe) : clears rectangle on screen

eade: bold : set bold if 1, set normal if 0
eb08: text mode?? : 0 = black on white (9800b2 set to 4) ; else: white background, no text (9800b2 set to 7)
eae4: y,x : set coordinates
eaf6: DrawText: print 0-terminated string
eacc: 2,coordinates,coordinates :  
ecd0: beep --> 0F70
ece2: reload system!
eb38: get key --> D0w  [ actual code at 12F4 ] ; sometimes waits, sometimes doesn't ??!
ec58 ?? write text at coordinates: 0.w, y.w, x.w, message.l, implemented at b164
calls 0F8E(1.l,1.l)
ec76: strcpy(dest,src)
ec94: strcat(dest,src)

trap #0 with D7=1C and D0=argument: pause for 16.9ms times argument (number of display frames, presumably)
D7=1D has similar arguments, but functionality is unknown; the 1C handler is apparently at 60000D70
trap handler starts at #6B52

ROM keyboard routine:
at 0x980700.w:  the current key
at 0x980702.b: 03 if a key is pressed and 00 otherwise
at 0x980704.w: the last key pressed (FFFF if spinner)
at 0x980706.b: 01 if last event was spinner and 00 if it was a key
at 0x98070A.w: the duration of last key down event (including spinner in any direction)
at 0x9a070C.b: 01 if last spinner movement was right and FF if it was left
at 0x9a070D.b: some sort of spinner speed value
at 0x9a070E.w: some kind of current spinner position, not corresponding to angle : a full rotation is about 115-122

  ;; there is some way to toggle whether keys click ; when loading as PVTEST_, they click ; when
  ;; loading as SYSTEM_, they don't
  none = 0000 (is there a flag to wait?)
  0 = 0240
  . = 0440
  chs = 0840
  1 = 0220
  2 = 0420
  3 = 0820
  4 = 0210
  5 = 0410
  6 = 0810
  clr = 0120
  stop = 0104
  7 = 0208
  8 = 0408
  9 = 0808
  don't care = 0110
  run = 0102
  A = 0204
  B = 0404
  C = 0804
  D = 0202
  E = 0402
  F = 0802
  format = 0101
  trace = 0201
  display = 0401
  io = 0801
  updown = 1040
  leftright = 2040
  select = 2001
  counterclockwise = 0082
  clockwise = 0081
  
HARDWARE
  
At 201000.w: graphics memory access mode control. Maybe some kind of mask and value? I can't figure it out.

But here is what I know. Only the first four bits of each byte of the mode register matter.
For all 256 possible modes, writing 0 bits to the screen does nothing. Only 1 bits do something.
There are four possible visible actions they can do: draw black, draw white, reverse pixel, 
nothing. I can't figure out the pattern of how the 256 modes map to the four actions. Moreover,
the 256 modes, even within the same visible action, differently affect what you can read from
screen memory in mode 7.

Reading a memory location returns 0 unless the low byte (or low nybble) is 3, 5, 6 or 7.

There is a distinction between what one finds in memory in one of the read modes and what is shown
on screen. For instance, if one writes bits in mode E06, one gets white pixels on screen that can be
read back as 1. But if one writes bits in mode E00, one gets white pixels on screen that read back
(after changing to a mode where reading works) as 0.

Here are some useful modes:
 FF00 --> $201000 = write black pixels without reading 
 FF06 --> $201000 = write black pixels with reading 
 FE00 --> $201000 = write white pixels without reading
 FE06 --> $201000 = write white pixels with reading
 0007 --> $201000 = reverses pixels written in black or white---but oddly does not seem to reverse 
					reversed pixels

What seems reliable for reading and writing is to use the xx06 modes exclusively. If you write in one
of the xx00 or 0007 modes, you can't always read back what's on the screen. For instance, writing in
0007 mode, you read back what you wrote, not what's on the screen.

On thing about reversing is super weird. It seems that each pixel has four modes: reversible black, reversible white,
irreversible black, and irreversible white. Writing in reverse mode takes reversible black to irreversible
white and reversible white to irreversible black. I wonder if this is some glitchy analog thing with the
video memory. 				
 
Here are some patterns:
	If bit 0 of low byte is 0, we always get white or black pixels (never reverse or NOP).
	If bit 3 of high byte is 1, we never get reversing.
	If bit 3 of high byte is 0 and low byte is 7, we get reverse (but not only then).
	If low byte is f, we get NOP (but not only then).
	If high byte is e, we get white for even low byte and NOP for odd low byte.
	If high byte is f, we get black for even low byte and NOP for odd low byte.
	Reading only works if and only if low byte is 3, 5, 6 or 7.
	
Low byte is recorded at 0x98077c
High byte is recorded at 0x98077e
When writing black on white text: 98077e: FFFB, 98077c: 0000, so should be FB00.

I have not found a way to read current screen buffer data, though interestingly you can read back
the last reverse-mode write to each bit (which is not the same as what is visible on screen),
as long as you are in reverse-mode. An ordinary write to the bit then clears the read back bit.
If this is reliable, you could do this trick. Clear the screen to black. Then treat reverse-write
as white-write, alternating between black-write and reverse-write as needed. (You could also do
this with white and black swapped.) Now that I think about it, maybe this is the intended way to 
use the screen? You would just need to ensure when you start a program that you clear the screen
to the desired background color. A nice way to do this in your program would be to set:
 #define WRITE_BACKGROUND WRITE_BLACK  // or WRITE_WHITE if you prefer
 #define WRITE_FOREGROUND WRITE_REVERSE
and start the program with 
 *SCREEN_MEMORY_CONTROL=WRITE_BACKGROUND; 
 fillScreen();
and then alternate writing between WRITE_BACKGROUND and WRITE_FOREGROUND as needed.

0x203000.b: BEEP: 0xFF on, $FE off

0x206000.b: spinner speed

0x207000.l (write): -1 does something spinnery

0x20d003.l: read/write. unknown. Serial port??

0x20F000.w:
bit 0: unknown, checked in a disc related context
bit 1: last spinner turn was to the right
bit 3: no disc in drive

_SYSTEM

Serial programming

Token/command table starts:
 00a023b8: string: COM^MAND [null terminated, 0x20 padded after null] : 0x0E bytes
           word: some sort of index that is non-increasing from entry to entry, sometimes staying the same
Address of token table stored in 00a23b8a		   

ROM File System

eb74 int OpenFile(char *filename,int filetype,int mode)
 Modes are either 1 (read) or 2 (write)
 E.g.: OpenFile(s_AUTOLOAD_000064da,0xc301,2);
       OpenFile("SYSTEM_",0xc001,1);
       OpenFile("PVTEST_",0xc001,1);	   
implemented at 390C	   
	
eb86 int ReadFile(int fd, void* out, int size) 
	if size is -1, reads to end (dangerous if you don't know the size)
	if out is NULL and size <= 64K, it presumably writes to ROM (I've seen this in ROM code to skip stuff in the file)
implemented at 3c98

eb80 int WriteFile(int fd,void* in,int size)
implemented at 3f96

eb7a CloseFile(int fparam)
implemented at 3a5c

eb98 FindDirEntry(char* filename,int16 type,char* direntry32bytes,uint32 searchStartIndex,uint32 filename_length); return -5 if filename doesn't exist; returns index in directory otherwise

ebce int GetDirEntry(int32 index,char* direntry32bytes);  returns -1 when done

0x984166: some kind of open file info area, with entries of length 0x138?	   

eb92: check if packing is needed??

eb9e: pack??

eb62: some kind of directory refresh
ebb0: some sort of status check; 0=ok
