Memory map:
1mb RAM from 980000 to A7FFFF 

code starts at 002C in the pvtest file, which is loaded at 0x984500 (this is 
probably user-selectable).
                 
Initial stack pointer: 00A7FFDE 

Strings are null terminated.

Screen size: 592x384
Some of the ROM routines (e.g., DrawString) enforce a margin.

From PVTEST_

992fe2+2: SetCoordinates:  push y, x
        0098a500 48  78  00       pea        (0xb4 ).w
                 b4
        0098a504 48  78  01       pea        (0x15c ).w
                 5c
        0098a508 4e  93           jsr        (A3 => LAB_00992fe2+2 )
        0098a50a 50  8f           addq.l     #0x8 ,SP

FUN_00993044: args: push string, push length 

FUN_00992ff6: DrawText: push string, zero terminated

FUN_00992fc0: DrawRect:
 push thickness, height, width, y, x
Good test location: 0098a3d6/5f02

LAB_00992fe6+4: DrawChar: push char (.w) to draw

FUN_00992fde.l: SetBold: push word: 1 bold, 0 normal

FUN_00993014: takes two coordinate pairs; line?

0098a078: DrawKeyboard

0098a934: TestKeys

FUN_00993038: get key --> D0 ; probably -1 is none

at 600000: graphics memory, draw in white by default.
screen: write word at a time to even addresses ; only lowest 4 bits matter

To switch to black:
    move.w     #4 ,-(SP ) ; other values 0,1,FF ;
    jsr        $0000eaba
    addq.l     #2 ,SP
 FF does nothing?!  00 draws black, 04 draws black, 

To turn off writing:
    move.w     #$fe ,-(SP )
    jsr        $0000eaae
    addq.l     #2 ,SP
# f1, f9, -9, fd, fb

The Level 1 interrupt autovector is at 60Hz, so it's probably the vertical blanking interrupt.
It can be used for a timer. 
 
$980716 is copied to $202000
 
Draw pixel in SYSTEM_:

void FUN_00a04b12(ushort param_1,ushort param_2)
{
  ushort uVar1;
  
  uVar1 = 8;
  if ((param_1 & 3) != 0) {
    uVar1 = 8 >> (param_1 & 3);
  }
  (x/4)*2 + y*(592/2) = 8 >> (x % 8)
  *(ushort *)((uint)((param_1 & 0xfffc) >> 1) + (uint)param_2 * 0x128 + 0x600000) = uVar1;
  return;
}

// only the last 4 bits of each display byte are used

From SYSTEM_:
	009c2482: SystemOpenFile (calls ROM's OpenFile)
	

ROM routines:

ead8: rectangle: 7,h,w,y,x ???? not quite

ea06: one arg 1e

eac6: 8,8,170,240 (after 0000eaae : fe) : clears rectangle on screen

eade: bold : set bold if 1, set normal if 0
eb08: text color?? : 0 = black on white (9800b2 set to 4) ; else: white background, no text (9800b2 set to 7)
eae4: y,x : set coordinates
eaf6: print 0-terminated string
eacc: 2,coordinates,coordinates :  
ecd0: beep --> 0F70
ece2: reload system!
eb38: get key --> D0w  [ actual code at 12F4 ] ; sometimes waits, sometimes doesn't ??!
ec58 ?? write text at coordinates: 0.w, y.w, x.w, message.l, implemented at b164
calls 0F8E(1.l,1.l)
ec76: strcpy(dest,src)
ec94: strcat(dest,src)

trap #0 with D7=1C and D0=argument: pause for 16.9ms times argument (number of display frames, presumably)
D7=1D has similar arguments, but functionality is unknown; the 1C handler is apparently at 60000D70
trap handler starts at #6B52

ROM keyboard routine:
at 0x980700.w:  the current key
at 0x980702.b: 03 if a key is pressed and 00 otherwise
at 0x980704.w: the last key pressed (FFFF if spinner)
at 0x980706.b: 01 if last event was spinner and 00 if it was a key
at 0x98070A.w: the duration of last key down event (including spinner in any direction)
at 0x9a070C.b: 01 if last spinner movement was right and FF if it was left
at 0x9a070D.b: some sort of spinner speed value
at 0x9a070E.w: some kind of current spinner position, not corresponding to angle : a full rotation is about 115-122

  ;; there is some way to toggle whether keys click ; when loading as PVTEST_, they click ; when
  ;; loading as SYSTEM_, they don't
  none = 0000 (is there a flag to wait?)
  0 = 0240
  . = 0440
  chs = 0840
  1 = 0220
  2 = 0420
  3 = 0820
  4 = 0210
  5 = 0410
  6 = 0810
  clr = 0120
  stop = 0104
  7 = 0208
  8 = 0408
  9 = 0808
  don't care = 0110
  run = 0102
  A = 0204
  B = 0404
  C = 0804
  D = 0202
  E = 0402
  F = 0802
  format = 0101
  trace = 0201
  display = 0401
  io = 0801
  updown = 1040
  leftright = 2040
  select = 2001
  counterclockwise = 0082
  clockwise = 0081
  
HARDWARE
  
At 201000.w: graphics writing mode control. Maybe some kind of mask and value? I can't figure it out
completely. But this seems to work:
 FF00 --> $201000 = write black pixels
 FE00 --> $201000 = write white pixels
 Other values like 0002 and 0008 sometimes reverse things. And sometimes they
 only seem to reverse pixels drawn in a certain mode.

0x203000.b: BEEP: 0xFF on, $FE off

0x206000.b: spinner speed

0x207000.l (write): -1 does something spinnery

0x20d003.l: read/write. unknown. Serial port??

0x20F000.b:
bit 0: unknown, checked in a disc related context
bit 1: last spinner turn was to the right
bit 4: no disc in drive

_SYSTEM

Serial programming

Token/command table starts:
 00a023b8: string: COM^MAND [null terminated, 0x20 padded after null] : 0x0E bytes
           word: some sort of index that is non-increasing from entry to entry, sometimes staying the same
Address of token table stored in 00a23b8a		   

ROM File System

eb74 int OpenFile(char *filename,short filetype,short mode)
 Modes are either 1 (read) or 2 (write)
 E.g.: OpenFile(s_AUTOLOAD_000064da,0xc301,2);
       OpenFile("SYSTEM_",0xc001,1);
       OpenFile("PVTEST_",0xc001,1);	   
implemented at 390C	   
	
eb86 int ReadFile(short fd, void* out, int size) ?? size could be -1??!; out could be NULL
implemented at 3c98

eb80 int WriteFile(short fd,void* in,int size)
implemented at 3f96

eb7a CloseFile(short fparam)
implemented at 3a5c

eb98 FindDirEntry(char* filename,uint16 type,char* direntry32bytes,uint32 searchStartIndex,uint32 filename_length); return -5 if filename doesn't exist; returns index in directory otherwise

ebce int GetDirEntry(int32 index,char* direntry32bytes);  returns -1 when done

0x984166: some kind of open file info area, with entries of length 0x138?	   

eb92: check if packing is needed??

eb9e: pack??