MEMORY MAP

00980000-00A7FFFF: 1mb RAM
00600000-0061FFFF: video RAM, multiplexed between two planes, each with 64kb x 4bits of data
00000000-0000FFFF: 64kb ROM
		 
Stuff happens in ROM regarding data in a60000-a6ffff, and maybe even A5FFFA=a60000-6, so it's probably 
safest to end program storage at a5fffa.

00983000-00983FFF appears to be unused in ROM. I'm putting the user stack for my code at 983ffe.

Stuff on a stack going down to a7fc6a plus some calls --> crash.

There seems to be some non-stack stuff going on at around 00a7fb00, with pinters to data at 00a7fc47.
I can't figure out what is accessing that data.

The supervisor stack was observed to be at 00a708b0 from the point of view of the vertical blanking interrupt
handler.

The user stack appears to be set to be 00a7fffe.
		 

EXECUTABLE FILE FORMAT

LIF file type 0xC001

0x0000: dword:    length
0x0004: char[20]: comment (space filled)
0x0024: dword:	  code length
0x0028: dword:    code loading location, normally 0x00984500
0x002C: char[code length]:  code
0x002c + code length: dword:   data(?) loading location, 0x00A20000 in PVTEST_ and SYSTEM_
0x002c + code length + 4: data to end of file

Observed initial stack pointer : 00A7FFDE 


VIDEO

Screen size: 592x384
Some of the ROM routines (e.g., DrawText) enforce an 8-pixel margin.

Apparently the video memory apparently consists of four bit-planes.
  plane 0: data
  plane 1: overlay-data (ODATA)
  plane 2: overlay (OV)
  plane 3: attribute (ATTR)
  
White=1, black=0.
If OV=0 and ODATA=0, the display pixel is DATA xor ATTR.
If OV=0 and ODATA=1, 
If OV=1, the display pixel is ODATA xor ATTR.

This allows one to have cursors, selection boxes and simple overlay windows without 
rewriting screen data.

The four planes are multiplexed for access at 0x600000. The data is stored row by
row, with four bits per machine word. Only the lowest four bits of each machine
word are valid, and they are displayed left-to-right from highest to lowest bit.

Screen address (x,y) corresponds to the word at address: 0x600000 + y*0x0128 + x/4*2,
with the relevant bit being 3-(x&0x3). 

Only 1 bits affect anything as they are written to screen memory: 0 bits are
completely ignored. To write a bit 1 to (x,y), you write a word to 
0x600000 + y*0x0128 + x/4*2 with the lowest byte 8>>(x&0x3).

All planes share the same addresses. At 0x00201000 there is a one-word screen memory 
control register that controls the multiplexing mode for the memory. This allows you
to control both which plane(s) you are writing to as well as whether writing a 1 bit
sets a bit or clears a bit in the plane(s). 

Only the lowest 4 bits of each byte of the mode register matter. 

The low byte of the memory control register controls which planes are active, with
clear=active.

The high byte controls what value is written to the active planes when a 1 bit is
written to screen memory, with the values reversed: clear writes 1 and set writes 0.

	For instance, mode = 0b010100001000 works as follows:
  1000: planes 0,1,2 active
  0101: when writing to a pixel, plane 0 is set to zero, plane 1 is set to 1, plane 2 is set to 0.

Reading reads from the active planes in a mode. When no planes are active, you get 0.
When only one plane is active, that's what you read. When two planes are active, you
get 1 providing at least one has a 1. When three or four planes are active, you get 1
providing at least two have a 1. Probably reading one plane at a time is the only useful
thing to do.

The simplest way is to restrict to using these modes:
 F00: set DATA to 1 (=white), clear other planes to 0
 E00: set DATA to 0 (=black), clear other planes to 0
 
For more advanced use cases, you can first clear all the non-data planes with F00 or E00,
and then use:
 007: set ATTR to 1 (=reverse data), leave other planes unchanged, read attr
 807: set ATTR to 0, leave other planes unchanged, read attr
 00E: set DATA to 1 (=white), leave other planes unchanged, read data
 10E: set DATA to 0 (=black), leave other planes unchanged, read data

The ROM routines store the current mode. At 0x98077c.w, we have the low byte, set via ROM function
eaae. At 0x98077e.w, we have the high byte, set with ROM function eaba. It's not a terrible idea to
restore this mode when done with your changes.

A full list of the modes is in screenmodes.txt. It was based on automated data gathering via
the c/idscreenmode program.


Font bitmap locations: a674 (bold), 9e74; 16 bytes per char 


INTERRUPTS

The Level 1 interrupt autovector is at 60Hz, so it's surely the vertical blanking interrupt.
It can be used for a timer. 

The default interrupt handlers are at: 
 1: 1024E (=024E) 
 2?: 1024E (=024E)
 3?:  B4BC (or B702 according to code)
	 Main result seems to be to move a byte from 20d003 to 9801f0 and then another to 9801f4.
 4?:  NONE (but maybe sometimes is B53E, which is disk related)
 6:  B904. interrupt 6 handler: Serial read/write
	 
	 9842fa
	 b914
 


SPECIAL HARDWARE ADDRESSES

0x200000 ??: involved in acquisition test
0x200001 ??: involved in acquisition test
0x201000.w: screen memory control (see below)  
0x202000 ??: write only
0x203000.b: BEEP: 0xFF on, $FE off
0x205000 ??: involved in spinner
0x205002 ??: involved in spinner
0x2050fe ??: involved in spinner
0x206000.b: spinner speed
0x207000 (write): -1 does something spinnery
0x20a000: direct i/o address
0x20a002: connected with serial test 
0x20a004: connected with serial test ; mode??
0x20a006: connected with serial test 
0x20a007: handshake i/o address
0x20d001.b: read. used in interrupt level 3 handler
0x20d003.b: read/write. unknown. used in interrupt level 3 handler and connected with disk i/o
0x20e001: ?? write
0x20F000.w:
	bit 0: if clear, disk has been changed and data needs refresh; set by call to ebb0
	bit 1: last spinner turn was to the right
	bit 3: no disk in drive
	bit 4: ???
0x400001 ??: involved in acquisition test
	
0xc00041.b: scope channel 1(?), read, 6 bits of data, plus the other two bits have individual meaning
0xc00061.b: scope channel 2(?), read, 6 bits of data
0xc00001.b: some kind of scope control, write	
0xc00003.b: some kind of scope control, write	
0xc00007.b: some kind of scope control, write	
0xc00009.b: some kind of scope control, write	
0xc00023.b: ditto	
0xc00025.b: ditto	
0xc0002b.b: ditto

To read, first write a load of 1s to 00c00023, at least 0x10, and maybe 800+0x10, and then read each
channel, and after reading it, write another 1 to 00c00023. Reading can go on to 0x800 times.


SERIAL

eb50: init serial
eb44: (int,char*): send to serial, but it never works for me: just hangs
ea06: called as if it was a read function, but actually may just be a delayTicks(ticks)
  9842bc.w: -1 to prepare, then returns numRead-1
  9842cc.l: address to put data
  9842c0.w: buffer size - 1
  9842f4.w: 0 to prepare, non-zero when buffer full
  9842e4.w: 1
at SYSTEM_:009acd28 we instead call ea0c(1,1,2,uint16_t* p) [ trap #0, D7=1A ]



For writing, it looks like:
  9842c8.l: address with data
  9842c2.w: data size
  
9842c4.l: input/output address base (0x20a000)

20a000: data i/o address (read/write)
20a002: SCN2661 Status Register
    0x20: DTR
20a004: SCN2661 Mode Register 1 MR10-17 on first write, then Mode Register 2 MR20-27 on second write
20a006: SCN2661 command register (read/write)
	0x20 : DCD (1=on)
	0x02 : DSR
20a00
http://matthieu.benoit.free.fr/cross/data_sheets/SCN2661.pdf

handshake i/o address (read/write)

At 984304 we have an internal buffer and a location index at 9842ea. Probably a 0x80 long
circular buffer.
  
ea0c? maybe also some kind of serial thing
pvtest 98cdee looks like sending
ditto 0098c68a--that looks like it may be sending and receiving and comparing
in SYSTEM_, baud rate option is stored at 00a286ca and protocol at 00a286c6 and bit count at 00a286c7

serialMode: eb5c(0x20a000, baudValue, parityOption, stopBitsOption, bitCountOption+3);
	
baudValue: 2=110,6=300,7=600,9=1200,0xC=2400,0xD=4800,0xE=9600,0xF=19200 : stored in 9842d8.w
stopBitsOption: 0=1,1=1.5,2=2 : stored in 9842d4.w
parityOptions: 0=none,1=odd,2=even : stored in 9842d6.w
bitCountOption+3: 3=7,4=8 : stored in 9842d2.w
	
Promising call to eb5c to set settings in FUN_0098f450 (SYSTEM_).
In PVTEST_: func_0x0000eb5c(0x20a000,0xe,0,1,4);
ProtocolSetting stored at: 0x9842d0.w : 0=hardware, 1=none, 2=xon/xoff
Parity stored at: DAT_00a286c9
Stop bits stored at: 00a286c8

ROM ROUTINES

ead8: rectangle: 7,h,w,y,x ???? not quite
eac6: 8,8,170,240 (after 0000eaae : fe) : clears rectangle on screen
eaba: set high byte of 0x201000 mode register to the logical not of the uint16_t argument
eaae: set low byte of 0x201000 mode regster to the uint16_t argument
eade: bold : set bold if 1, set normal if 0
eb08: text mode?? : 0 = black on white (9800b2 set to 4) ; else: white background, no text (9800b2 set to 7)
eae4: y,x : set coordinates
eaf6: DrawText: print 0-terminated string
eacc: 2,coordinates,coordinates :  
ecd0: beep --> 0F70
ece2: reload system!
eb38: getkey --> D0w  [ actual code at 12F4 ] ; sometimes waits, sometimes doesn't ??!
eb3e: get a character from a 64-byte circular buffer at 980048 (serial? HPIB? used by SYSTEM_ for inputs)
eb32: put a character in this circular buffer
	  I don't know what this circular buffer is for. One could use it to feed inputs into the system, 
	  as SYSTEM_ is happy to take input from it in preference to the keyboard when there is data in it.
ec58 ?? write text at coordinates: 0.w, y.w, x.w, message.l, implemented at b164
calls 0F8E(1.l,1.l)
ec76: strcpy(dest,src)
ec94: strcat(dest,src)
ebe0: compare(char*,char*,int): some kind of comparison with special casing for ?
ea06: delay ticks, apparently (implemented 8002)  

trap #0 with D7=1C and D0=argument: pause for 16.9ms times argument (number of display frames, presumably)
D7=1D has similar arguments, but functionality is unknown; the 1C handler is apparently at 60000D70
trap handler starts at #6B52


KEYBOARD

ROM keyboard handler maintains this data:
at 0x980700.w:  the current key
at 0x980702.b: 03 if a key is pressed and 00 otherwise
at 0x980704.w: the last key pressed (FFFF if spinner)
at 0x980706.b: 01 if last event was spinner and 00 if it was a key
at 0x98070A.w: the duration of last key down event (including spinner in any direction)
at 0x9a070C.b: 01 if last spinner movement was right and FF if it was left
at 0x9a070D.b: some sort of spinner speed value
at 0x9a070E.w: some kind of current spinner position, not corresponding to angle : a full rotation is about 115-122

  none = 0000 
  0 = 0240
  . = 0440
  chs = 0840
  1 = 0220
  2 = 0420
  3 = 0820
  4 = 0210
  5 = 0410
  6 = 0810
  clr = 0120
  stop = 0104
  7 = 0208
  8 = 0408
  9 = 0808
  don't care = 0110
  run = 0102
  A = 0204
  B = 0404
  C = 0804
  D = 0202
  E = 0402
  F = 0802
  format = 0101
  trace = 0201
  display = 0401
  io = 0801
  updown = 1040
  leftright = 2040
  select = 2001
  counterclockwise = 0082
  clockwise = 0081


DISK I/O

Filenames are up to 10 characters long, padded with spaces, and case-sensitive.

eb74 int OpenFile(char *filename,int filetype,int mode)
 Modes are either 1 (read) or 2 (write)
 E.g.: OpenFile(s_AUTOLOAD_000064da,0xc301,2);
       OpenFile("SYSTEM_",0xc001,1);
       OpenFile("PVTEST_",0xc001,1);	   
implemented at 390C	   
	
eb86 int ReadFile(int fd, void* out, int size) 
	if size is -1, reads to end (dangerous if you don't know the size)
	if out is NULL and size <= 64K, it presumably writes to ROM (I've seen this in ROM code to skip stuff in the file)
implemented at 3c98

eb80 int WriteFile(int fd,void* in,int size)
implemented at 3f96

eb7a CloseFile(int fparam)
implemented at 3a5c

eb98 FindDirEntry(char* filename,int16 type,char* direntry32bytes,uint32 searchStartIndex,uint32 filename_length)
	return -5 if filename doesn't exist; returns index in directory otherwise.
	These are standard LIF directory entries.
	I've been having this hang!

ebce int GetDirEntry(int32 index,char* direntry32bytes);  returns -1 when done; else, returns data 
	TODO: Check if direntry only needs 12 bytes, and only includes filename and filetype, or is the full
		direntry.

0x984166: some kind of open file info area, with entries of length 0x138?	   

eb9e: pack??

eb62: some kind of directory refresh prep, taking one argument
ebb0: directory refresh; 0=ok; afterwards, 0x00984154 has the start of the A165 label from the LIF header;
	sets the old disk flag on 0x200f000
ec10: does most of the work of ebb0, but I think it doesn't close files (!)	
ebf2: SetAutoload(int dirEntryNumber, char? status);	
ebc8: Rename(int dirEntryNumber, struct NameAndType_t* name); 
      Can be used to delete by setting type to zero.
	  typedef struct {
	     char name[10];
		 uint16_t type;
	  } NameAndType_t;

ec82: some sort of string formatting

ROM code suggests that only one file can be open at once, as some routines check to see if fparam is <= 0
and exit if not.

2db0 is involved in 20d003 stuff, and is ROM EC16 function. In SYSTEM_, EC16 is called
as part of the disk copying code. Other functions used in copying: ebb6, eb62, eb6e (format?!), ebaa, eb92,

432c: clear directory

directory stored at 9800ca and 9808ac (sometimes?). In latter location changed with ebb0.
9808ac is where the data is primarily stored.
eba4 (implemented 327e) looks like it may load the whole dir
ebfe: read block

Some PVTEST_ functions:
FUN_00993044: args: push string, push length 
FUN_00992ff6: DrawText: push string, zero terminated
FUN_00992fc0: DrawRect:
 push thickness, height, width, y, x
LAB_00992fe6+4: DrawChar: push char (.w) to draw
FUN_00992fde.l: SetBold: push word: 1 bold, 0 normal
FUN_00993014: takes two coordinate pairs; line?
0098a078: DrawKeyboard
0098a934: TestKeys
FUN_00993038: get key --> D0 ; probably -1 is none
FUN_00987f96: print a message, where 3 is RS232C start and 4 is RS232C end and message number is at 00a2026a
FUN_00987a86: print a message, where 3 is RS232C start and 4 is RS232C end

098b660: rs232c test

SYSTEM_ purge completed message number #14

disk packing and other file operations in SYSTEM_ 00987c04 case 1e
pack/rename/purge/format


NOTES ON SYSTEM_

0xa32a64: lookup table for oscilloscope channel data (0-0x3f)

009c2482: SystemOpenFile (calls ROM's OpenFile)

Serial programming token/command table starts:
 00a023b8: string: COM^MAND [null terminated, 0x20 padded after null] : 0x0E bytes
           word: some sort of index that is non-increasing from entry to entry, sometimes staying the same
Address of token table stored in 00a23b8a		   

At FUN_00984ec6 have list of various functions with 4 character codes for them. FileOperations is
one of them. The nth functions calls ECFA with the third argument being n.


 FUN_009856ac: ecfa 1: CmdD
 
 FUN_009b03e8: maybe print(size, char*)
 
 FUN_009c174a: some sort of big complicated file operation thingy
 
 
Internal font: B

01100011
00010000
01101100
10000000
01100111
01100110
01101110
01100110
00000000
01100110
00000000
01100110
00000000
00000000
00000000
00000000
