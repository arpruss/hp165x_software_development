MEMORY MAP

00980000-00A7FFFF: 1mb RAM
00600000-0061FFFF: video RAM, multiplexed between two planes, each with 64kb x 4bits of data
00000000-0000FFFF: 64kb ROM
		 
Stuff happens in ROM regarding data in a60000-a6ffff, so it's probably safest to 
end program storage at a5ffff.
		 

EXECUTABLE FILE FORMAT

LIF file type 0xC001

0x0000: dword:    length
0x0004: char[20]: comment (space filled)
0x0024: dword:	  code length
0x0028: dword:    code loading location, normally 0x00984500
0x002C: char[code length]:  code
0x002c + code length: dword:   data(?) loading location, 0x00A20000 in PVTEST_ and SYSTEM_
0x002c + code length + 4: data to end of file

Observed initial stack pointer : 00A7FFDE 

Strings are null terminated.


VIDEO

Screen size: 592x384
Some of the ROM routines (e.g., DrawText) enforce an 8-pixel margin.

Apparently the video memory apparently consists of four bit-planes.
  plane 0: data
  plane 1: overlay-data (ODATA)
  plane 2: overlay (OV)
  plane 3: attribute (ATTR)
  
White=1, black=0.
If OV=0 and ODATA=0, the display pixel is DATA xor ATTR.
If OV=0 and ODATA=1, 
If OV=1, the display pixel is ODATA xor ATTR.

This allows one to have cursors, selection boxes and simple overlay windows without 
rewriting screen data.

The four planes are multiplexed for access at 0x600000. The data is stored row by
row, with four bits per machine word. Only the lowest four bits of each machine
word are valid, and they are displayed left-to-right from highest to lowest bit.

Screen address (x,y) corresponds to the word at address: 0x600000 + y*0x0128 + x/4*2,
with the relevant bit being 3-(x&0x3). 

Only 1 bits affect anything as they are written to screen memory: 0 bits are
completely ignored. To write a bit 1 to (x,y), you write a word to 
0x600000 + y*0x0128 + x/4*2 with the lowest byte 8>>(x&0x3).

All planes share the same addresses. At 0x00201000 there is a one-word screen memory 
control register that controls the multiplexing mode for the memory. This allows you
to control both which plane(s) you are writing to as well as whether writing a 1 bit
sets a bit or clears a bit in the plane(s). 

Only the lowest 4 bits of each byte of the mode register matter. 

The low byte of the memory control register controls which planes are active, with
clear=active.

The high byte controls what value is written to the active planes when a 1 bit is
written to screen memory, with the values reversed: clear writes 1 and set writes 0.

For instance, mode = 0b010100001000 works as follows:
  1000: planes 0,1,2 active
  0101: when writing to a pixel, plane 0 is set to zero, plane 1 is set to 1, plane 2 is set to 0.

Reading reads from the active planes in a mode. When no planes are active, you get 0.
When only one plane is active, that's what you read. When two planes are active, you
get 1 providing at least one has a 1. When three or four planes are active, you get 1
providing at least two have a 1. Probably reading one plane at a time is the only useful
thing to do.

The simplest way is to restrict to using these modes:
 F00: set DATA to 1 (=white), clear other planes to 0
 E00: set DATA to 0 (=black), clear other planes to 0
 
For more advanced use cases, you can first clear all the non-data planes with F00 or E00,
and then use:
 007: set ATTR to 1 (=reverse data), leave other planes unchanged, read attr
 807: set ATTR to 0, leave other planes unchanged, read attr
 00E: set DATA to 1 (=white), leave other planes unchanged, read data
 10E: set DATA to 0 (=black), leave other planes unchanged, read data

The ROM routines store the current mode. At 0x98077c.w, we have the low byte, set via ROM function
eaae. At 0x98077e.w, we have the high byte, set with ROM function eaba. It's not a terrible idea to
restore this mode when done with your changes.

A full list of the modes is in screenmodes.txt. It was based on automated data gathering via
the c/idscreenmode program.


Font bitmap locations: a674 (bold), 9e74; 16 bytes per char 


INTERRUPTS

The Level 1 interrupt autovector is at 60Hz, so it's surely the vertical blanking interrupt.
It can be used for a timer. 

The default interrupt handlers are at: 
 1: 1024E (=024E) 
 2: 1024E (=024E)
 3:  B4BC (or B702 according to code)
	 Main result seems to be to move a byte from 20d003 to 9801f0 and then another to 9801f4.
 4:  NONE (but maybe sometimes is B53E)
 5:  B904
	 Super complicated code.
	 
	 9842fa
	 b914
 


SPECIAL HARDWARE ADDRESSES

0x200000 ??: involved in acquisition test
0x200001 ??: involved in acquisition test
0x201000.w: screen memory control (see below)  
0x202000 ??: write only
0x203000.b: BEEP: 0xFF on, $FE off
0x205000 ??: involved in spinner
0x205002 ??: involved in spinner
0x2050fe ??: involved in spinner
0x206000.b: spinner speed
0x207000 (write): -1 does something spinnery
0x20a000: has some connection with interrupt level 5 handler and ROM eb5c 
0x20a002: connected with serial test 
0x20a004: connected with serial test 
0x20a006: connected with serial test 
0x20a007: ditto
0x20d001.b: used in interrupt level 3 handler
0x20d003.b: read/write. unknown. used in interrupt level 3 handler and may be connected with disk i/o
0x20e001: ?? write
0x20F000.w:
	bit 0: if clear, disk has been changed and data needs refresh; set by call to ebb0
	bit 1: last spinner turn was to the right
	bit 3: no disk in drive
	bit 4: ???
	
	
SERIAL

Maybe eb44, ea06
pvtest 98cdee looks like sending
ditto 0098c68a--that looks like it may be sending and receiving and comparing



ROM ROUTINES

ead8: rectangle: 7,h,w,y,x ???? not quite
eac6: 8,8,170,240 (after 0000eaae : fe) : clears rectangle on screen
eaba: set high byte of 0x201000 mode register to the logical not of the uint16_t argument
eaae: set low byte of 0x201000 mode regster to the uint16_t argument
eade: bold : set bold if 1, set normal if 0
eb08: text mode?? : 0 = black on white (9800b2 set to 4) ; else: white background, no text (9800b2 set to 7)
eae4: y,x : set coordinates
eaf6: DrawText: print 0-terminated string
eacc: 2,coordinates,coordinates :  
ecd0: beep --> 0F70
ece2: reload system!
eb38: getkey --> D0w  [ actual code at 12F4 ] ; sometimes waits, sometimes doesn't ??!
eb3e: get a character from a 64-byte circular buffer at 980048 (serial? HPIB? used by SYSTEM_ for inputs)
eb32: put a character in this circular buffer
	  I don't know what this circular buffer is for. One could use it to feed inputs into the system, 
	  as SYSTEM_ is happy to take input from it in preference to the keyboard when there is data in it.
ec58 ?? write text at coordinates: 0.w, y.w, x.w, message.l, implemented at b164
calls 0F8E(1.l,1.l)
ec76: strcpy(dest,src)
ec94: strcat(dest,src)
ebe0: compare(char*,char*,int): some kind of comparison with special casing for ?

trap #0 with D7=1C and D0=argument: pause for 16.9ms times argument (number of display frames, presumably)
D7=1D has similar arguments, but functionality is unknown; the 1C handler is apparently at 60000D70
trap handler starts at #6B52


KEYBOARD

ROM keyboard handler maintains this data:
at 0x980700.w:  the current key
at 0x980702.b: 03 if a key is pressed and 00 otherwise
at 0x980704.w: the last key pressed (FFFF if spinner)
at 0x980706.b: 01 if last event was spinner and 00 if it was a key
at 0x98070A.w: the duration of last key down event (including spinner in any direction)
at 0x9a070C.b: 01 if last spinner movement was right and FF if it was left
at 0x9a070D.b: some sort of spinner speed value
at 0x9a070E.w: some kind of current spinner position, not corresponding to angle : a full rotation is about 115-122

  none = 0000 
  0 = 0240
  . = 0440
  chs = 0840
  1 = 0220
  2 = 0420
  3 = 0820
  4 = 0210
  5 = 0410
  6 = 0810
  clr = 0120
  stop = 0104
  7 = 0208
  8 = 0408
  9 = 0808
  don't care = 0110
  run = 0102
  A = 0204
  B = 0404
  C = 0804
  D = 0202
  E = 0402
  F = 0802
  format = 0101
  trace = 0201
  display = 0401
  io = 0801
  updown = 1040
  leftright = 2040
  select = 2001
  counterclockwise = 0082
  clockwise = 0081


DISK I/O

eb74 int OpenFile(char *filename,int filetype,int mode)
 Modes are either 1 (read) or 2 (write)
 E.g.: OpenFile(s_AUTOLOAD_000064da,0xc301,2);
       OpenFile("SYSTEM_",0xc001,1);
       OpenFile("PVTEST_",0xc001,1);	   
implemented at 390C	   
	
eb86 int ReadFile(int fd, void* out, int size) 
	if size is -1, reads to end (dangerous if you don't know the size)
	if out is NULL and size <= 64K, it presumably writes to ROM (I've seen this in ROM code to skip stuff in the file)
implemented at 3c98

eb80 int WriteFile(int fd,void* in,int size)
implemented at 3f96

eb7a CloseFile(int fparam)
implemented at 3a5c

eb98 FindDirEntry(char* filename,int16 type,char* direntry32bytes,uint32 searchStartIndex,uint32 filename_length)
	return -5 if filename doesn't exist; returns index in directory otherwise.
	These are standard LIF directory entries.

ebce int GetDirEntry(int32 index,char* direntry32bytes);  returns -1 when done; else, returns data 
	TODO: Check if direntry only needs 12 bytes, and only includes filename and filetype, or is the full
		direntry.

0x984166: some kind of open file info area, with entries of length 0x138?	   

eb9e: pack??

eb62: some kind of directory refresh prep, taking one argument
ebb0: directory refresh; 0=ok; afterwards, 0x00984154 has the start of the A165 label from the LIF header;
	sets the old disk flag on 0x200f000
ebf2: SetAutoload(int dirEntryNumber, char? status);	
ebc8: Rename(int dirEntryNumber, struct NameAndType_t* name); 
      Can be used to delete by setting type to zero.
	  typedef struct {
	     char name[10];
		 uint16_t type;
	  } NameAndType_t;

ec82: some sort of string formatting

ROM code suggests that only one file can be open at once, as some routines check to see if fparam is <= 0
and exit if not.

2db0 is involved in 20d003 stuff, and is ROM EC16 function. In SYSTEM_, EC16 is called
as part of the disk copying code. Other functions used in copying: ebb6, eb62, eb6e (format?!), ebaa, eb92,

Some PVTEST_ functions:
FUN_00993044: args: push string, push length 
FUN_00992ff6: DrawText: push string, zero terminated
FUN_00992fc0: DrawRect:
 push thickness, height, width, y, x
LAB_00992fe6+4: DrawChar: push char (.w) to draw
FUN_00992fde.l: SetBold: push word: 1 bold, 0 normal
FUN_00993014: takes two coordinate pairs; line?
0098a078: DrawKeyboard
0098a934: TestKeys
FUN_00993038: get key --> D0 ; probably -1 is none


SYSTEM_ purge completed message number #14

disk packing in SYSTEM_ 00987c04 case 1e
pack/rename/purge/format


NOTES ON SYSTEM_

009c2482: SystemOpenFile (calls ROM's OpenFile)

Serial programming token/command table starts:
 00a023b8: string: COM^MAND [null terminated, 0x20 padded after null] : 0x0E bytes
           word: some sort of index that is non-increasing from entry to entry, sometimes staying the same
Address of token table stored in 00a23b8a		   

